name: Download Binance Data to Azure

on:
  # Scheduled: run daily at 00:05 UTC
  schedule:
    - cron: '5 0 * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      symbols:
        description: 'Symbols to download (comma-separated or "all")'
        required: true
        default: 'all'
        type: string
      config_path:
        description: 'Config file path'
        required: true
        default: 'configs/btcusdt_1m_dev.jsonc'
        type: string
      image_tag:
        description: 'Docker image tag'
        required: true
        default: 'latest'
        type: string

env:
  ACR_LOGIN_SERVER: itbacr.azurecr.io
  ACR_REPOSITORY: itb-bot
  AZURE_RESOURCE_GROUP: rg-itb-dev
  AZURE_STORAGE_ACCOUNT: stitbdev
  AZURE_FILE_SHARE: data-itb-1m
  DATA_MOUNT_PATH: /app/DATA_ITB_1m

jobs:
  download:
    name: Download ${{ matrix.symbol }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        symbol: ${{ github.event.inputs.symbols == 'all' && fromJson('["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "XRPUSDT"]') || fromJson(format('["{0}"]', github.event.inputs.symbols)) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set variables
        id: vars
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          CONTAINER_NAME="itb-download-${{ matrix.symbol }}-${TIMESTAMP}"
          echo "container_name=${CONTAINER_NAME,,}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: Download ${{ matrix.symbol }} via Azure Container Instance
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          SYMBOL="${{ matrix.symbol }}"
          IMAGE_TAG="${{ github.event.inputs.image_tag || 'latest' }}"
          DOCKER_IMAGE="${{ env.ACR_LOGIN_SERVER }}/${{ env.ACR_REPOSITORY }}:${IMAGE_TAG}"

          echo "üöÄ Starting download for ${SYMBOL}"
          echo "   Container: ${CONTAINER_NAME}"
          echo "   Image: ${DOCKER_IMAGE}"

          # Create container that downloads directly to Azure File Share
          az container create \
            --name "${CONTAINER_NAME}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "${DOCKER_IMAGE}" \
            --os-type Linux \
            --registry-login-server "${{ env.ACR_LOGIN_SERVER }}" \
            --registry-username "${{ secrets.ACR_USERNAME }}" \
            --registry-password "${{ secrets.ACR_PASSWORD }}" \
            --restart-policy Never \
            --cpu 1 \
            --memory 2 \
            --azure-file-volume-share-name "${{ env.AZURE_FILE_SHARE }}" \
            --azure-file-volume-account-name "${{ env.AZURE_STORAGE_ACCOUNT }}" \
            --azure-file-volume-account-key "${{ secrets.AZURE_STORAGE_KEY }}" \
            --azure-file-volume-mount-path "${{ env.DATA_MOUNT_PATH }}" \
            --environment-variables \
              BINANCE_API_KEY="${{ secrets.BINANCE_API_KEY }}" \
              BINANCE_API_SECRET="${{ secrets.BINANCE_API_SECRET }}" \
              SYMBOL="${SYMBOL}" \
            --command-line "python -m scripts.download_binance -c configs/${SYMBOL,,}_1m_dev.jsonc" \
            --no-wait

          echo "‚è≥ Waiting for container to complete..."
          for i in {1..120}; do
            STATE=$(az container show \
              --name "${CONTAINER_NAME}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --query 'instanceView.state' -o tsv 2>/dev/null || echo "Pending")

            echo "[$i/120] Container state: ${STATE}"

            if [ "$STATE" = "Succeeded" ]; then
              echo "‚úÖ Download completed successfully!"
              break
            elif [ "$STATE" = "Failed" ]; then
              echo "‚ùå Download failed!"
              az container logs --name "${CONTAINER_NAME}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}"
              exit 1
            fi

            sleep 10
          done

      - name: Get container logs
        if: always()
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          echo "üìú Container logs:"
          az container logs \
            --name "${CONTAINER_NAME}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" || echo "No logs available"

      - name: Cleanup container
        if: always()
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          echo "üßπ Cleaning up container..."
          az container delete \
            --name "${CONTAINER_NAME}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --yes || true

  # After all downloads, run merge + features
  process:
    name: Process Data (merge + features)
    needs: download
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Trigger merge + features pipeline
        run: |
          echo "üîÑ Triggering merge + features pipeline..."
          # This could call the existing merge-only-aci workflow
          # Or run directly here

          CONTAINER_NAME="itb-process-$(date +%Y%m%d-%H%M%S)"
          IMAGE_TAG="${{ github.event.inputs.image_tag || 'latest' }}"
          DOCKER_IMAGE="${{ env.ACR_LOGIN_SERVER }}/${{ env.ACR_REPOSITORY }}:${IMAGE_TAG}"
          CONFIG_PATH="${{ github.event.inputs.config_path || 'configs/btcusdt_1m_dev.jsonc' }}"

          az container create \
            --name "${CONTAINER_NAME}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "${DOCKER_IMAGE}" \
            --os-type Linux \
            --registry-login-server "${{ env.ACR_LOGIN_SERVER }}" \
            --registry-username "${{ secrets.ACR_USERNAME }}" \
            --registry-password "${{ secrets.ACR_PASSWORD }}" \
            --restart-policy Never \
            --cpu 1 \
            --memory 2 \
            --azure-file-volume-share-name "${{ env.AZURE_FILE_SHARE }}" \
            --azure-file-volume-account-name "${{ env.AZURE_STORAGE_ACCOUNT }}" \
            --azure-file-volume-account-key "${{ secrets.AZURE_STORAGE_KEY }}" \
            --azure-file-volume-mount-path "${{ env.DATA_MOUNT_PATH }}" \
            --command-line "sh -c 'python -m scripts.merge_new -c ${CONFIG_PATH} && python -m scripts.features_new -c ${CONFIG_PATH}'" \
            --no-wait

          echo "‚è≥ Waiting for processing to complete..."
          for i in {1..60}; do
            STATE=$(az container show \
              --name "${CONTAINER_NAME}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --query 'instanceView.state' -o tsv 2>/dev/null || echo "Pending")

            echo "[$i/60] Container state: ${STATE}"

            if [ "$STATE" = "Succeeded" ] || [ "$STATE" = "Failed" ]; then
              break
            fi
            sleep 10
          done

          az container logs --name "${CONTAINER_NAME}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}"
          az container delete --name "${CONTAINER_NAME}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --yes || true

  notify:
    name: Notify completion
    needs: [download, process]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Send Telegram notification
        if: env.TELEGRAM_BOT_TOKEN != ''
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          STATUS="${{ needs.download.result == 'success' && needs.process.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}"
          MESSAGE="üìä Binance Download Pipeline

          Status: ${STATUS}
          Symbols: ${{ github.event.inputs.symbols || 'all' }}
          Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          Download: ${{ needs.download.result }}
          Process: ${{ needs.process.result }}"

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d chat_id="${TELEGRAM_CHAT_ID}" \
            -d text="${MESSAGE}" \
            -d parse_mode="HTML" || true
